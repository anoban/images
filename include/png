#pragma once
#include <algorithm>
#include <helpers>
#include <imageio>

#include <Winsock2.h> // for the byte order reversal routines
#pragma comment(lib, "Ws2_32.lib")

// PNG (Portable Network Graphics) is the newest image format compared to JPEG, BMP and GIF
// PNG uses loseless compression and supports:
// 1) up to 48 bits pixel depth
// 2) 1, 2, 4, 8, 16 bit sample precisions
// 3) alpha channel for full colour transparency
// 4) complicated colour matching ??

// PNG stores multibyte integers in MSB first order (Big Endian)
// bit strings are read from the least to the most significant bit ?? (related to Huffman codes), when a bit string steps over a byte boundary,
// bits in the second byte become the most significant ?? (Huffman codes)

// huffman codes within the compressed data are stored with their bits reversed.
// MSB of the Huffman codes will be the LSB of the data byte and vice versa.

// a PNG file is composed of a array of chunks.
// PNG chunks can be defined by three entities:
// 1) PNG standard - most important chunks all PNG decoders must be able of parse
// 2) public - a list of chunk specs submitted by the public and accepted by the PNG standard
// 3) private - chunks defined by applications e.g. Adobe PhotoShop (these chunks are often used internally by these applications)

// every PNG chunk consists of 4 parts:
// 1) length - number of bytes in the data segment (BE, unsigned)
// 2) type - chunk name/identifier (a string literal of 4 characters)
// 3) data - a series of bytes (contiguous array of length number of bytes)
// 4) CRC - a Cyclic Redundancy Check (CRC32) checksum value (BE, unsigned)

class png_chunk final {
        unsigned       length;
        char           type[4]; // NOLINT(modernize-avoid-c-arrays)
        unsigned char* data;
        unsigned       checksum;

        constexpr bool is_critical() const noexcept {
            // a chunk with uppercase first letter is considered a critical chunk, all decoders must be able to parse the critical chunks
            return ascii::is_upper(type[0]);
        }

        constexpr bool is_valid() const noexcept {
            // any chunk with non printing ASCII characters in its name must be deemed invalid
            // first, second and the fourth character in the name can be an uppercase or a lowercase letter
            // third character MUST be an uppercase ASCII letter
            return std::all_of(std::begin(type), std::end(type), is_character) && ascii::is_upper(type[2]);
        }

        constexpr bool is_private() const noexcept {
            // second character of public chunk types and chunk types approved by the PNG development group will be in uppercase
            // private chunks defined by applications must have a lowercase second character, in order not to conflict with publicly defined chunks
            return ascii::is_lower(type[1]);
        }

        // if a chunk is safe to copy, the last alphabet of the chunk name shall be in lowercase (NOT ALWAYS)
        // a decoder shall not attempt to copy a non-copy-safe chunk if it doesn't recognize it
        // i.e there are chunks with uppercase last letter that are safe to copy, like the PNG standards defined IHDR, IDAT, IEND ... chunks
        // this lowercase rule applies as a fallback only when the decoder cannot recognize a chunk
};

// A decoder only needs to parse standard defined PNG chunks that follow the above structure.
//    It shall ignore chunks that are not in compliance with the above specified format, private chunks and newly incorporated public chunks.

/*

    There are 4 critical chunks each PNG file is expected to contain:
        1) IHDR
        2) PLTE
        3) IDAT
        4) IEND

*/

class png final { };
