#pragma once
#include <algorithm>
#include <helpers>
#include <imageio>

#include <Winsock2.h> // for the byte order reversal routines
#pragma comment(lib, "Ws2_32.lib")

// PNG (Portable Network Graphics) is the newest image format compared to JPEG, BMP and GIF
// PNG uses loseless compression and supports:
// 1) up to 48 bits pixel depth
// 2) 1, 2, 4, 8, 16 bit sample precisions
// 3) alpha channel for full colour transparency
// 4) complicated colour matching ??

// PNG stores multibyte integers in MSB first order (Big Endian)
// bit strings are read from the least to the most significant bit ?? (related to Huffman codes), when a bit string steps over a byte boundary,
// bits in the second byte become the most significant ?? (Huffman codes)

// huffman codes within the compressed data are stored with their bits reversed.
// MSB of the Huffman codes will be the LSB of the data byte and vice versa.

// a PNG file is composed of a array of chunks.
// PNG chunks can be defined by three entities:
// 1) PNG standard - most important chunks all PNG decoders must be able of parse
// 2) public - a list of chunk specs submitted by the public and accepted by the PNG standard
// 3) private - chunks defined by applications e.g. Adobe PhotoShop (these chunks are often used internally by these applications)

// every PNG chunk consists of 4 parts:
// 1) length - number of bytes in the data segment (BE, unsigned)
// 2) type - chunk name/identifier (a string literal of 4 characters)
// 3) data - a series of bytes (contiguous array of length number of bytes)
// 4) CRC - a Cyclic Redundancy Check (CRC32) checksum value (BE, unsigned)

class png_chunk final {
        unsigned       length;
        char           type[4]; // NOLINT(modernize-avoid-c-arrays)
        unsigned char* data;
        unsigned       checksum;

        // a PNG chunk name consist of 4 ASCII characters

        static constexpr bool is_character(_In_ const char character) noexcept {
            return (character >= 65 && character <= 90) /* A - Z */ || (character >= 97 && character <= 122); /* a - z */
        }

        static constexpr bool is_upper(_In_ const char character) noexcept {
            return character >= 65 && character <= 90; /* A - 65 and Z - 90 */
        }

        static constexpr bool is_lower(_In_ const char character) noexcept {
            return character >= 97 && character <= 122; /* a - 97 and z - 122 */
        }

        constexpr bool is_critical() const noexcept { return png_chunk::is_upper(type[0]); }

        constexpr bool is_valid() const noexcept {
            // any chunk with non printing ASCII characters in its name must be deemed invalid
            // first, second and the fourth character in the name can be an uppercase or a lowercase letter
            // third character MUST be an uppercase ASCII letter
            return std::all_of(std::begin(type), std::end(type), is_character) && ascii::is_upper(type[2]);
        }

        constexpr bool is_private() const noexcept {
            // second character of public chunk types and chunk types approved by the PNG development group will be in uppercase
            // private chunks defined by applications must have a lowercase second character, in order not to conflict with publicly defined chunks
            return ascii::is_lower(type[1]);
        }
};

// A decoder only needs to parse standard defined PNG chunks that follow the above structure.
//    It shall ignore chunks that are not in compliance with the above specified format, private chunks and newly incorporated public chunks.
//
//    CHUNK NAMES
//
//
//
//
//

/*

    There are 4 critical chunks each PNG file is expected to contain:
        1) IHDR
        2) PLTE
        3) IDAT
        4) IEND

    Second character of public chunk types and chunk types approved by the PNG development group will be in uppercase.
    Private chunks defined by applications must have a lowercase second character, in order not to conflict with publicly defined chunks.

    COPY SAFE CHUNKS

    The last alphabet of the chunk name will be in lowercase, if the chunk is safe to copy.
    A decoder shall not attempt to copy non copy-safe chunks if it doesn't recognize them.

    e.g.

*/

class png final { };
