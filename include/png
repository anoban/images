#pragma once
#include <algorithm>
#include <helpers>
#include <imageio>
#include <string_view>

#include <Winsock2.h> // for the byte order reversal routines
#pragma comment(lib, "Ws2_32.lib")

// PNG (Portable Network Graphics) is the newest image format compared to JPEG, BMP and GIF
// PNG uses loseless compression and supports:
// 1) up to 48 bits pixel depth
// 2) 1, 2, 4, 8, 16 bit sample precisions
// 3) alpha channel for full colour transparency
// 4) complicated colour matching ??

// PNG stores multibyte integers in MSB first order (Big Endian)
// bit strings are read from the least to the most significant bit ?? (related to Huffman codes), when a bit string steps over a byte boundary,
// bits in the second byte become the most significant ?? (Huffman codes)

// huffman codes within the compressed data are stored with their bits reversed.
// MSB of the Huffman codes will be the LSB of the data byte and vice versa.

// a PNG file is composed of a array of chunks.
// PNG chunks can be defined by three entities:
// 1) PNG standard - most important chunks all PNG decoders must be able of parse
// 2) public - a list of chunk specs submitted by the public and accepted by the PNG standard
// 3) private - chunks defined by applications e.g. Adobe PhotoShop (these chunks are often used internally by these applications)

// every PNG chunk consists of 4 parts:
// 1) length - number of bytes in the data segment (BE, unsigned)
// 2) type - chunk name/identifier (a string literal of 4 characters)
// 3) data - a series of bytes (contiguous array of length number of bytes)
// 4) CRC - a Cyclic Redundancy Check (CRC32) checksum value (BE, unsigned)

// a decoder only needs to parse standard defined PNG chunks that follow the above structure
// it shall ignore chunks that are not in compliance with the above specified format, private chunks and newly incorporated public chunks

class png_chunk final {
        unsigned       length;
        char           type[4]; // NOLINT(modernize-avoid-c-arrays)
        unsigned char* data;
        unsigned       checksum;

        constexpr bool is_critical() const noexcept {
            // a chunk with uppercase first letter is considered a critical chunk, all PNG decoders must be able to parse the critical chunks
            return ascii::is_upper(type[0]);
        }

        constexpr bool is_valid() const noexcept {
            // any chunk with non printing ASCII characters in its name must be deemed invalid
            // first, second and the fourth character in the name can be an uppercase or a lowercase letter
            // third character MUST be an uppercase ASCII letter
            return ::is_character_array(type) && ascii::is_upper(type[2]);
        }

        constexpr bool is_private() const noexcept {
            // second character of public chunk types and chunk types approved by the PNG development group will be in uppercase
            // private chunks defined by applications must have a lowercase second character, in order not to conflict with publicly defined chunks
            return ascii::is_lower(type[1]);
        }

        // if a chunk is safe to copy, the last alphabet of the chunk name shall be in lowercase (NOT ALWAYS)
        // a decoder shall not attempt to copy a non-copy-safe chunk if it doesn't recognize it
        // i.e there are chunks with uppercase last letter that are safe to copy, like the PNG standards defined IHDR, IDAT, IEND ... chunks
        // this lowercase rule applies as a fallback only when the decoder cannot recognize a chunk

    public:
};

namespace critical { // there are 4 critical chunks each PNG file is expected to contain - IHDR, PLTE, IDAT and IEND
    static constexpr std::array<char, 4> IHDR { 'I', 'H', 'D', 'R' }; // image header, the first chunk in a PNG data stream
    static constexpr std::array<char, 4> PLTE { 'P', 'L', 'T', 'E' }; // palette table
    static constexpr std::array<char, 4> IDAT { 'I', 'D', 'A', 'T' }; // image chunk
    static constexpr std::array<char, 4> IEND { 'I', 'E', 'N', 'D' }; // image trailer, the last chunk in a PNG data stream
} // namespace critical

template<unsigned long long size> static constexpr typename std::enable_if<size == 4, bool>::type
operator==(                        // this overloaded operator== is only intended to compare PNG chunk names!
    _In_ const char (&left)[size], // NOLINT(modernize-avoid-c-arrays)
    _In_ const std::array<char, size>& right
) noexcept {
    return left[0] == right[0] && left[1] == right[1] && left[2] == right[2] && left[3] == right[3];
}

template<unsigned long long size> static constexpr typename std::enable_if<size == 4, bool>::type
operator==( // this overloaded operator== is only intended to compare PNG chunk names!
    _In_ const std::array<char, size>& left,
    _In_ const char (&right)[size] // NOLINT(modernize-avoid-c-arrays)
) noexcept {
    return left[0] == right[0] && left[1] == right[1] && left[2] == right[2] && left[3] == right[3];
}

class png final {
    public:
        png() noexcept = default;
};
