#include <canvas>
#include <cmaps>
#include <complex>

namespace fractals {

    // look up https://en.wikipedia.org/wiki/Mandelbrot_set
    static canvas mandelbrot_set(_In_ const long& width, _In_ const long& height) noexcept {
        canvas mandelbrot { width, height };

        double             cr {}, ci {}, nextr {}, nexti {}, prevr {}, previ {}; // NOLINT(readability-isolate-declaration)
        constexpr unsigned MAX_ITERATIONS { 1000 };

        for (long y = 0; y < mandelbrot.height(); ++y) {
            for (long x = 0; x < mandelbrot.width(); ++x) {
                cr = 1.5 * (2.0 * x / mandelbrot.width() - 1.0) - 0.5;
                ci = (2.0 * y / mandelbrot.height() - 1.0);

                for (unsigned i = 0; i < MAX_ITERATIONS; ++i) {
                    prevr = nextr;
                    previ = nexti;

                    nextr = prevr * prevr - previ * previ + cr;
                    nexti = 2 * prevr * previ + ci;

                    if (((nextr * nextr) + (nexti * nexti)) > 4) {
                        const double z = ::sqrt(nextr * nextr + nexti * nexti);

                        // https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring
                        const unsigned int index =
                            static_cast<unsigned int>(1000.0 * log2(1.75 + i - log2(log2(z))) / log2(MAX_ITERATIONS));

                        mandelbrot[x + y * mandelbrot.height()] = colourmaps::JET.at(index);

                        break;
                    }
                }
            }
        }

        return mandelbrot;
    }

    // look up https://en.wikipedia.org/wiki/Tricorn_(mathematics)
    static canvas tricorn(_In_ const long& width, _In_ const long& height) noexcept {
        canvas               tricorn { width, height }; // prepare the canvas
                                                        // NOLINTNEXTLINE(readability-isolate-declaration)
        double               scaled_x_coordinate {} /* (-2.5, 1) */, scaled_y_coordinate {} /* (-1, 1) */; // of the pixel
        std::complex<double> cmplx {};

        constexpr auto     MAX_ITERATIONS { CMAPSIZE };
        double             realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)
        unsigned long long iterations {};

        // for each pixel in the image
        for (long row = 0; row < tricorn.height(); ++row) {
            for (long col = 0; col < tricorn.width(); ++col) {
                // dividing col by width gives a value (0, 1), multiplying that by 3.500 upscales to to (0, 3.5), then subtracting 2.5 gives us (-2.5, 1)
                scaled_x_coordinate = col / static_cast<double>(tricorn.width()) * 3.50000 - 2.50000;
                // dividing row by height will give a value (0, 1), by multiplying by 2 we could stretch it to (0, 2), then by subtracting 1, we could shift the range to (-1, 1)
                scaled_y_coordinate = row / static_cast<double>(tricorn.height()) * 2.00000 - 1.00000;

                cmplx               = { scaled_x_coordinate, scaled_y_coordinate };

                realsq              = cmplx.real() * cmplx.real();
                imagsq              = cmplx.imag() * cmplx.imag();
                iterations          = 0;

                while (realsq + imagsq < 4.0000 && ++iterations < MAX_ITERATIONS) {
                    realtemp = realsq - imagsq + scaled_x_coordinate;
                    cmplx    = { realtemp, -2.000 * cmplx.real() * cmplx.imag() + scaled_y_coordinate };
                }

                tricorn[row * tricorn.height() + col] =
                    (iterations == MAX_ITERATIONS) ? RGBQUAD { 0x00, 0x00, 0x00, 0xFF } : colourmaps::PRISM.at(iterations);
            }
        }

        return tricorn;
    }

    // look up https://en.wikipedia.org/wiki/Julia_set
    static canvas julia_set(_In_ const long& width, _In_ const long& height) noexcept { }
} // namespace fractals
