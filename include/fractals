#include <canvas>
#include <cmaps>
#include <cmath>
#include <helpers> // for complex<> because std::complex<>'s real() and imag() methods return a const reference even when the object is non const
// and it uses a 2 member array as the internal storage structure, so to update individual elements we need to expose the array and manually subscript into it
// opting for a handrolled  complex, fucking C++ heh???

namespace fractals {

    static constexpr RGBQUAD BLACK { .rgbBlue = 0x00, .rgbGreen = 0x00, .rgbRed = 0x00, .rgbReserved = 0xFF };

    // look up https://en.wikipedia.org/wiki/Mandelbrot_set
    [[nodiscard]] static canvas __cdecl mandelbrot(_In_ const long& width, _In_ const long& height) noexcept {
        canvas mandelbrot { width, height };

        double             cr {}, ci {}, nextr {}, nexti {}, prevr {}, previ {}; // NOLINT(readability-isolate-declaration)
        constexpr unsigned MAX_ITERATIONS { 1000 };

        for (long row = 0; row < mandelbrot.height(); ++row) {
            for (long col = 0; col < mandelbrot.width(); ++col) {
                cr = 1.5 * (2.0 * col / mandelbrot.width() - 1.0) - 0.5;
                ci = (2.0 * row / mandelbrot.height() - 1.0);

                for (unsigned i = 0; i < MAX_ITERATIONS; ++i) {
                    prevr = nextr;
                    previ = nexti;

                    nextr = prevr * prevr - previ * previ + cr;
                    nexti = 2 * prevr * previ + ci;

                    if (((nextr * nextr) + (nexti * nexti)) > 4) {
                        const double z = ::sqrt(nextr * nextr + nexti * nexti);

                        // https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring
                        const unsigned int index =
                            static_cast<unsigned int>(1000.0 * log2(1.75 + i - log2(log2(z))) / log2(MAX_ITERATIONS));

                        mandelbrot[col + row * mandelbrot.height()] = colourmaps::JET.at(index);

                        break;
                    }
                }
            }
        }

        return mandelbrot;
    }

    // look up https://en.wikipedia.org/wiki/Tricorn_(mathematics)
    [[nodiscard]] static canvas __cdecl tricorn(_In_ const long& width, _In_ const long& height) noexcept {
        canvas            tricorn { width, height }; // prepare the canvas
                                                     // NOLINTNEXTLINE(readability-isolate-declaration)
        double            scaled_x_coordinate {} /* (-2.5, 1) */, scaled_y_coordinate {} /* (-1, 1) */; // of the pixel
        ::complex<double> scaled_coordinates {};

        constexpr auto     MAX_ITERATIONS { CMAPSIZE };
        volatile double    realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)
        unsigned long long iterations {};

        // for each pixel in the image
        for (long row = 0; row < tricorn.height(); ++row) {
            for (long col = 0; col < tricorn.width(); ++col) {
                // dividing col by width gives a value (0, 1), multiplying that by 3.500 upscales to to (0, 3.5), then subtracting 2.5 gives us (-2.5, 1)
                scaled_x_coordinate       = col / static_cast<double>(tricorn.width()) * 3.50000 - 2.50000;
                // dividing row by height will give a value (0, 1), by multiplying by 2 we could stretch it to (0, 2), then by subtracting 1, we could shift the range to (-1, 1)
                scaled_y_coordinate       = row / static_cast<double>(tricorn.height()) * 2.00000 - 1.00000;

                scaled_coordinates.real() = scaled_x_coordinate;
                scaled_coordinates.imag() = scaled_y_coordinate;

                realsq                    = scaled_coordinates.real() * scaled_coordinates.real();
                imagsq                    = scaled_coordinates.imag() * scaled_coordinates.imag();
                iterations                = 0;

                while (realsq + imagsq < 4.0000 && ++iterations < MAX_ITERATIONS) {
                    realtemp                  = realsq - imagsq + scaled_x_coordinate;
                    // IT IS ABSOULUTELY CRITICAL THAT WHEN THE IMAGINARY PART IS UPDATED, THE USED REAL PART SHOULD BE IN THE ORIGINAL (PREVIOUS) STATE
                    scaled_coordinates.imag() = -2.000 * scaled_coordinates.real() * scaled_coordinates.imag() + scaled_y_coordinate;
                    scaled_coordinates.real() = realtemp; // THUS UPDATING THE REAL PART AFTER THE UPDATE OF IMAGINARY PART
                }

                tricorn[row * tricorn.height() + col] = iterations == MAX_ITERATIONS ? BLACK : colourmaps::PRISM.at(iterations);
            }
        }

        return tricorn;
    }

    // look up https://en.wikipedia.org/wiki/Julia_set
    [[nodiscard]] static canvas __cdecl julia(
        _In_ const long&   width,
        _In_ const long&   height,
        _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
    ) noexcept {
        canvas            julia { width, height };
        ::complex<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

        const double   escaperadsq { escape_radius * escape_radius };
        constexpr auto MAX_ITERATIONS { CMAPSIZE };

        unsigned long iterations {};
        double        realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)

        // for each pixel in the image
        for (long row = 0; row < julia.height(); ++row) {
            for (long col = 0; col < julia.width(); ++col) {
                // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                // same goes for the col too
                scaled_coordinates = { (col / static_cast<double>(julia.width()) * 2.000 - 1.0000) * escape_radius,
                                       (row / static_cast<double>(julia.height()) * 2.000 - 1.0000) * escape_radius };

                iterations         = 0;
                realsq             = scaled_coordinates.real() * scaled_coordinates.real();
                imagsq             = scaled_coordinates.imag() * scaled_coordinates.imag();

                while (realsq + imagsq < escaperadsq && ++iterations < MAX_ITERATIONS) {
                    //
                    realtemp           = realsq - imagsq;
                    scaled_coordinates = {};
                }
            }
        }
    }

    // lookup https://en.wikipedia.org/wiki/Julia_set
    [[nodiscard]] static canvas __cdecl multijulia(
        _In_ const long&   width,
        _In_ const long&   height,
        _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
    ) noexcept {
        canvas            julia { width, height };
        ::complex<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

        const auto     escaperadsq { escape_radius * escape_radius };
        constexpr auto MAX_ITERATIONS { CMAPSIZE };

        unsigned long iterations {};
        double        realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)

        // for each pixel in the image
        for (long row = 0; row < julia.height(); ++row) {
            for (long col = 0; col < julia.width(); ++col) {
                // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                // same goes for the col too
                scaled_coordinates = { (col / static_cast<double>(julia.width()) * 2.000 - 1.0000) * escape_radius,
                                       (row / static_cast<double>(julia.height()) * 2.000 - 1.0000) * escape_radius };

                iterations         = 0;
                realsq             = scaled_coordinates.real() * scaled_coordinates.real();
                imagsq             = scaled_coordinates.imag() * scaled_coordinates.imag();

                while (realsq + imagsq < escaperadsq && ++iterations < MAX_ITERATIONS) {
                    //
                    realtemp           = realsq - imagsq;
                    scaled_coordinates = {};
                }
            }
        }
    }
} // namespace fractals
