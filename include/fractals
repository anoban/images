#include <canvas>
#include <cmaps>
#include <complex>

namespace fractals {

    static constexpr RGBQUAD BLACK { .rgbBlue = 0x00, .rgbGreen = 0x00, .rgbRed = 0x00, .rgbReserved = 0xFF };

    // look up https://en.wikipedia.org/wiki/Mandelbrot_set
    static canvas mandelbrot(_In_ const long& width, _In_ const long& height) noexcept {
        canvas mandelbrot { width, height };

        double             cr {}, ci {}, nextr {}, nexti {}, prevr {}, previ {}; // NOLINT(readability-isolate-declaration)
        constexpr unsigned MAX_ITERATIONS { 1000 };

        for (long row = 0; row < mandelbrot.height(); ++row) {
            for (long col = 0; col < mandelbrot.width(); ++col) {
                cr = 1.5 * (2.0 * col / mandelbrot.width() - 1.0) - 0.5;
                ci = (2.0 * row / mandelbrot.height() - 1.0);

                for (unsigned i = 0; i < MAX_ITERATIONS; ++i) {
                    prevr = nextr;
                    previ = nexti;

                    nextr = prevr * prevr - previ * previ + cr;
                    nexti = 2 * prevr * previ + ci;

                    if (((nextr * nextr) + (nexti * nexti)) > 4) {
                        const double z = ::sqrt(nextr * nextr + nexti * nexti);

                        // https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring
                        const unsigned int index =
                            static_cast<unsigned int>(1000.0 * log2(1.75 + i - log2(log2(z))) / log2(MAX_ITERATIONS));

                        mandelbrot[col + row * mandelbrot.height()] = colourmaps::JET.at(index);

                        break;
                    }
                }
            }
        }

        return mandelbrot;
    }

    // look up https://en.wikipedia.org/wiki/Tricorn_(mathematics)
    static canvas tricorn(_In_ const long& width, _In_ const long& height) noexcept {
        canvas               tricorn { width, height }; // prepare the canvas
                                                        // NOLINTNEXTLINE(readability-isolate-declaration)
        double               scaled_x_coordinate {} /* (-2.5, 1) */, scaled_y_coordinate {} /* (-1, 1) */; // of the pixel
        std::complex<double> cmplx {};

        constexpr auto     MAX_ITERATIONS { CMAPSIZE };
        double             realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)
        unsigned long long iterations {};

        // for each pixel in the image
        for (long row = 0; row < tricorn.height(); ++row) {
            for (long col = 0; col < tricorn.width(); ++col) {
                // dividing col by width gives a value (0, 1), multiplying that by 3.500 upscales to to (0, 3.5), then subtracting 2.5 gives us (-2.5, 1)
                scaled_x_coordinate = col / static_cast<double>(tricorn.width()) * 3.50000 - 2.50000;
                // dividing row by height will give a value (0, 1), by multiplying by 2 we could stretch it to (0, 2), then by subtracting 1, we could shift the range to (-1, 1)
                scaled_y_coordinate = row / static_cast<double>(tricorn.height()) * 2.00000 - 1.00000;

                cmplx               = { scaled_x_coordinate, scaled_y_coordinate };

                realsq              = cmplx.real() * cmplx.real();
                imagsq              = cmplx.imag() * cmplx.imag();
                iterations          = 0;

                while (realsq + imagsq < 4.0000 && ++iterations < MAX_ITERATIONS) {
                    realtemp = realsq - imagsq + scaled_x_coordinate;
                    cmplx    = { realtemp, -2.000 * cmplx.real() * cmplx.imag() + scaled_y_coordinate };
                }

                tricorn[row * tricorn.height() + col] = (iterations == MAX_ITERATIONS) ? BLACK : colourmaps::PRISM.at(iterations);
            }
        }

        return tricorn;
    }

    // look up https://en.wikipedia.org/wiki/Julia_set
    static canvas julia(
        _In_ const long&   width,
        _In_ const long&   height,
        _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
    ) noexcept {
        canvas               julia { width, height };
        std::complex<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

        const double   escaperadsq { escape_radius * escape_radius };
        unsigned long  iterations {};
        constexpr auto MAX_ITERATIONS { CMAPSIZE };
        double         realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)

        // for each pixel in the image
        for (long row = 0; row < julia.height(); ++row) {
            for (long col = 0; col < julia.width(); ++col) {
                // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                // same goes for the col too
                scaled_coordinates = { (col / static_cast<double>(julia.width()) * 2.000 - 1.0000) * escape_radius,
                                       (row / static_cast<double>(julia.height()) * 2.000 - 1.0000) * escape_radius };

                iterations         = 0;
                realsq             = scaled_coordinates.real() * scaled_coordinates.real();
                imagsq             = scaled_coordinates.imag() * scaled_coordinates.imag();

                while (realsq + imagsq < escaperadsq && ++iterations < MAX_ITERATIONS) {
                    //
                    realtemp           = realsq - imagsq;
                    scaled_coordinates = {};
                }
            }
        }
    }
} // namespace fractals
