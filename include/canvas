#pragma once
#include <bitmap>
#include <cmaps>

// std::complex<>'s x() and y() methods return a const reference even when the object is non const
// and it uses a 2 member array as the internal storage structure, so to update individual elements we need to expose the array and manually subscript into it
// opting for a handrolled  complex, fucking C++ heh???

#include <immintrin.h>

class canvas final : public bitmap { // a drawing canvas that uses bitmaps as their internal resource

    public:
        canvas(_In_ const long width, _In_ const long height) noexcept : bitmap { width, height } { }

        explicit canvas(_In_ const bitmap& image) noexcept : bitmap { image } { }

        explicit canvas(_In_ bitmap&& image) noexcept : bitmap { std::move(image) } { }

        ~canvas() noexcept = default;

        void fill(_In_ const RGBQUAD& pixel) noexcept { std::fill(begin(), end(), pixel); }

        // transform the image to black and white using the selected mechanism
        template<rgb::BW_TRANSFORMATION method> void to_blacknwhite() noexcept {
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE          : std::for_each(begin(), end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE : std::for_each(begin(), end(), rgb::transformers::weighted_average); break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY       : std::for_each(begin(), end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY           : std::for_each(begin(), end(), rgb::transformers::binary); break;
            }
        }

        template<rgb::BW_TRANSFORMATION method> [[nodiscard]] canvas to_blacknwhite() const noexcept {
            auto copy { *this };
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE : std::for_each(copy.begin(), copy.end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE :
                    std::for_each(copy.begin(), copy.end(), rgb::transformers::weighted_average);
                    break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY : std::for_each(copy.begin(), copy.end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY     : std::for_each(copy.begin(), copy.end(), rgb::transformers::binary); break;
            }
            return copy;
        }

        // remove the selected colours from the pixels of the image
        template<rgb::RGB_TAG colour_combination> void remove_colour() noexcept {
            std::for_each(begin(), end(), rgb::removers::zero<colour_combination> {});
        }

        template<rgb::RGB_TAG colour_combination> [[nodiscard]] canvas remove_colour() const noexcept {
            auto copy { *this };
            std::for_each(copy.begin(), copy.end(), rgb::removers::zero<colour_combination> {});
            return copy;
        }

        void hflip() noexcept { }

        [[nodiscard]] canvas hflip() const noexcept { }

        void vflip() noexcept {           // reverse the order of scanlines in the image
            __m512i    top {}, bottom {}; // NOLINT(readability-isolate-declaration)
            const long residues /* in RGBQUADs */ { static_cast<long>(width() % (sizeof(__m512i) / sizeof(RGBQUAD))) };
            RGBQUAD    temp {};
            long       col {}, row {}; // NOLINT(readability-isolate-declaration)
            // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic)
            for (row = 0; row < height() / 2 /* deliberate integer division */;
                 ++row) { // we slice the height into half, if the height is an even number,
                // cool, we process all the rows, if it is an odd number we leave the middle one untouced, no probs

                for (col  = 0; col < width() - residues;
                     col += (sizeof(__m512i) / sizeof(RGBQUAD)) // number of RGBQUAD structs a zmm register can hold
                ) {
                    // keep swapping the scanlines
                    top    = ::_mm512_loadu_epi8(pixels + width() * row + col);
                    bottom = ::_mm512_loadu_epi8(pixels + width() * (height() - row + 1) + col);
                    ::_mm512_storeu_epi8(pixels + width() * row + col, bottom);
                    ::_mm512_storeu_epi8(pixels + width() * (height() - row + 1) + col, top);
                }

                for (; col < width(); ++col) { // handle the residues
                    temp                                         = pixels[width() * row + col];
                    pixels[width() * row + col]                  = pixels[width() * (height() - row + 1) + col];
                    pixels[width() * (height() - row + 1) + col] = temp;
                }
            }
            // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
        }

        [[nodiscard]] canvas vflip() const noexcept { }

        [[nodiscard]] canvas copy() const noexcept { return *this; }

        [[nodiscard]] bitmap /* a non-destructive object slicing happens here */ unwrap() const noexcept { return *this; }

        static constexpr RGBQUAD FOREGROUND { .rgbBlue = 0xAA, .rgbGreen = 0xFF, .rgbRed = 0x00, .rgbReserved = 0xFF };

        // most of Wikipdia's fractal implementations have a lot of show stopping bugs, even though these are all inspired from
        // Wikipedia's implementations, these contain numerous refactors to fix those bugs
        // and thse fractal functions behave as if the scanlines in the pixel buffer are ordered top-down, since these are fractals, this is not much of an issue here

        void __cdecl mandelbrot(_In_ const colourmap& cmap) noexcept { // look up https://en.wikipedia.org/wiki/Mandelbrot_set
            // NOLINTNEXTLINE(readability-isolate-declaration)
            double               scaled_x_coordinate {} /* (-2.00, 0.47) */, scaled_y_coordinate {} /* (-1.12, 1.12) */;
            ::coordinate<double> scaled_coordinates {};

            constexpr auto     MAX_ITERATIONS { CMAPSIZE };
            double             xtemp {}, xsq {}, ysq {}; // NOLINT(readability-isolate-declaration)
            unsigned long long iterations {};

            // for each pixel in the image
            for (long row = 0; row < height(); ++row) {
                for (long col = 0; col < width(); ++col) {
                    // dividing col by width gives a value (0, 1), multiplying that by 2.4700 upscales to to (0, 2.4700), then subtracting 2.000 gives us (-2.000, 0.4700)
                    scaled_x_coordinate    = col / static_cast<double>(width()) * 2.47000 - 2.0000;
                    // dividing row by height will give a value (0, 1), subtracting 0.500 shifts it to (-0.5, 0.5) then by multiplying by 2.2400 we could stretch it to (-1.1200, 1.1200)
                    scaled_y_coordinate    = (row / static_cast<double>(height()) - 0.5000) * 2.24000;

                    scaled_coordinates.x() = scaled_x_coordinate;
                    scaled_coordinates.y() = scaled_y_coordinate;

                    iterations             = 0;

                    for (xsq = scaled_coordinates.x() * scaled_coordinates.x(), ysq = scaled_coordinates.y() * scaled_coordinates.y();
                         xsq + ysq < 4.000 && iterations < MAX_ITERATIONS;
                         ++iterations) {
                        xtemp                  = xsq - ysq + scaled_x_coordinate;
                        // IT IS ABSOULUTELY CRITICAL THAT WHEN THE IMAGINARY PART IS UPDATED, THE USED REAL PART SHOULD BE IN THE ORIGINAL (PREVIOUS) STATE
                        scaled_coordinates.y() = 2.000 * scaled_coordinates.x() * scaled_coordinates.y() + scaled_y_coordinate;
                        scaled_coordinates.x() = xtemp; // THUS UPDATING THE REAL PART AFTER THE UPDATE OF IMAGINARY PART
                    }

                    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)
                    pixels[row * height() + col] = (iterations == MAX_ITERATIONS) ? FOREGROUND : cmap.at(iterations);
                }
            }
        }

        void __cdecl tricorn(_In_ const colourmap& cmap) noexcept { // look up https://en.wikipedia.org/wiki/Tricorn_(mathematics)
            // NOLINTNEXTLINE(readability-isolate-declaration)
            double               scaled_x_coordinate {} /* (-2.5, 1) */, scaled_y_coordinate {} /* (-1, 1) */; // of the pixel
            ::coordinate<double> scaled_coordinates {};

            constexpr auto     MAX_ITERATIONS { CMAPSIZE };
            double             xtemp {}, xsq {}, ysq {}; // NOLINT(readability-isolate-declaration)
            unsigned long long iterations {};

            // for each pixel in the image
            for (long row = 0; row < height(); ++row) {
                for (long col = 0; col < width(); ++col) {
                    // dividing col by width gives a value (0, 1), multiplying that by 3.500 upscales to to (0, 3.5), then subtracting 2.5 gives us (-2.5, 1)
                    scaled_x_coordinate    = col / static_cast<double>(width()) * 3.50000 - 2.50000;
                    // dividing row by height will give a value (0, 1), by multiplying by 2 we could stretch it to (0, 2), then by subtracting 1, we could shift the range to (-1, 1)
                    scaled_y_coordinate    = row / static_cast<double>(height()) * 2.00000 - 1.00000;

                    scaled_coordinates.x() = scaled_x_coordinate;
                    scaled_coordinates.y() = scaled_y_coordinate;

                    iterations             = 0;

                    for (xsq = scaled_coordinates.x() * scaled_coordinates.x(), ysq = scaled_coordinates.y() * scaled_coordinates.y();
                         xsq + ysq < 4.000 && iterations < MAX_ITERATIONS;
                         ++iterations) {
                        xtemp                  = xsq - ysq + scaled_x_coordinate;
                        scaled_coordinates.y() = -2.000 * scaled_coordinates.x() * scaled_coordinates.y() + scaled_y_coordinate;
                        scaled_coordinates.x() = xtemp;
                    }

                    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)
                    pixels[row * height() + col] = (iterations == MAX_ITERATIONS) ? FOREGROUND : cmap.at(iterations);
                }
            }
        }

        void __cdecl julia( // look up https://en.wikipedia.org/wiki/Julia_set
            _In_ const colourmap& cmap,
            _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
        ) noexcept {
            ::coordinate<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

            const double   escrsq { escape_radius * escape_radius };
            constexpr auto MAX_ITERATIONS { CMAPSIZE };

            unsigned long iterations {};
            double        xtemp {};

            // for each pixel in the image
            for (long row = 0; row < height(); ++row) {
                for (long col = 0; col < width(); ++col) {
                    // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                    // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                    // same goes for the col too
                    scaled_coordinates.x() = (col / static_cast<double>(width()) * 2.000 - 1.0000) * escape_radius;
                    scaled_coordinates.y() = (row / static_cast<double>(height()) * 2.000 - 1.0000) * escape_radius;

                    iterations             = 0;

                    while (scaled_coordinates.x() * scaled_coordinates.x() + scaled_coordinates.y() * scaled_coordinates.y() < escrsq &&
                           ++iterations < MAX_ITERATIONS) {
                        //
                        xtemp = scaled_coordinates.x() * scaled_coordinates.x() - scaled_coordinates.y() * scaled_coordinates.y();
                        scaled_coordinates = {};
                    }
                }
            }
        }

        void __cdecl multijulia( // lookup https://en.wikipedia.org/wiki/Julia_set
            _In_ const colourmap& cmap,
            _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
        ) noexcept {
            ::coordinate<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

            const auto     escaperadsq { escape_radius * escape_radius };
            constexpr auto MAX_ITERATIONS { CMAPSIZE };

            unsigned long iterations {};
            double        xtemp {}, xsq {}, ysq {}; // NOLINT(readability-isolate-declaration)

            // for each pixel in the image
            for (long row = 0; row < height(); ++row) {
                for (long col = 0; col < width(); ++col) {
                    // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                    // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                    // same goes for the col too
                    scaled_coordinates = { (col / static_cast<double>(width()) * 2.000 - 1.0000) * escape_radius,
                                           (row / static_cast<double>(height()) * 2.000 - 1.0000) * escape_radius };

                    iterations         = 0;
                    xsq                = scaled_coordinates.x() * scaled_coordinates.x();
                    ysq                = scaled_coordinates.y() * scaled_coordinates.y();

                    while (xsq + ysq < escaperadsq && ++iterations < MAX_ITERATIONS) {
                        //
                        xtemp              = xsq - ysq;
                        scaled_coordinates = {};
                    }
                }
            }
        }
};
