#pragma once
#include <bitmap>
#include <cmaps>

// std::complex<>'s real() and imag() methods return a const reference even when the object is non const
// and it uses a 2 member array as the internal storage structure, so to update individual elements we need to expose the array and manually subscript into it
// opting for a handrolled  complex, fucking C++ heh???

#include <immintrin.h>

class canvas final : public bitmap { // a drawing canvas that uses bitmaps as their internal resource

    public:
        canvas(_In_ const long width, _In_ const long height) noexcept : bitmap { width, height } { }

        explicit canvas(_In_ const bitmap& image) noexcept : bitmap { image } { }

        explicit canvas(_In_ bitmap&& image) noexcept : bitmap { std::move(image) } { }

        ~canvas() noexcept = default;

        void fill(_In_ const RGBQUAD& pixel) noexcept { std::fill(begin(), end(), pixel); }

        // transform the image to black and white using the selected mechanism
        template<rgb::BW_TRANSFORMATION method> void to_blacknwhite() noexcept {
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE          : std::for_each(begin(), end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE : std::for_each(begin(), end(), rgb::transformers::weighted_average); break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY       : std::for_each(begin(), end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY           : std::for_each(begin(), end(), rgb::transformers::binary); break;
            }
        }

        template<rgb::BW_TRANSFORMATION method> [[nodiscard]] canvas to_blacknwhite() const noexcept {
            auto copy { *this };
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE : std::for_each(copy.begin(), copy.end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE :
                    std::for_each(copy.begin(), copy.end(), rgb::transformers::weighted_average);
                    break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY : std::for_each(copy.begin(), copy.end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY     : std::for_each(copy.begin(), copy.end(), rgb::transformers::binary); break;
            }
            return copy;
        }

        // remove the selected colours from the pixels of the image
        template<rgb::RGB_TAG colour_combination> void remove_colour() noexcept {
            std::for_each(begin(), end(), rgb::removers::zero<colour_combination> {});
        }

        template<rgb::RGB_TAG colour_combination> [[nodiscard]] canvas remove_colour() const noexcept {
            auto copy { *this };
            std::for_each(copy.begin(), copy.end(), rgb::removers::zero<colour_combination> {});
            return copy;
        }

        void hflip() noexcept { }

        [[nodiscard]] canvas hflip() const noexcept { }

        void vflip() noexcept { // reverse the order of scanlines in the image

            __m512i    top {}, bottom {}; // NOLINT(readability-isolate-declaration)
            const auto residues { info_header.biWidth % sizeof(__m512i) };

            for (long row = 0; row < info_header.biHeight / 2; ++row) {
                unsigned i {};
                for (i = 0; i < info_header.biWidth - residues; i += sizeof(__m512i)) { // keep swapping the scanlines

                    top    = ::_mm512_loadu_epi8(pixels + info_header.biWidth * row + i);
                    bottom = ::_mm512_loadu_epi8(pixels + (info_header.biWidth * info_header.biHeight) - (info_header.biWidth * row + i));

                    ::_mm512_storeu_epi8(pixels + info_header.biWidth * row + i, bottom);
                    ::_mm512_storeu_epi8(pixels + (info_header.biWidth * info_header.biHeight) - (info_header.biWidth * row + i), top);
                }

                while (i++ < info_header.biWidth) { // handle the residues
                    //
                }
            }
        }

        [[nodiscard]] canvas vflip() const noexcept { }

        [[nodiscard]] canvas copy() const noexcept { return *this; }

        // a non-destructive object slicing happens here
        [[nodiscard]] bitmap unwrap() const noexcept { return *this; }

        static constexpr RGBQUAD BLACK { .rgbBlue = 0x00, .rgbGreen = 0x00, .rgbRed = 0x00, .rgbReserved = 0xFF };

        // look up https://en.wikipedia.org/wiki/Mandelbrot_set
        void __cdecl mandelbrot() noexcept {
            double             cr {}, ci {}, nextr {}, nexti {}, prevr {}, previ {}; // NOLINT(readability-isolate-declaration)
            constexpr unsigned MAX_ITERATIONS { 1000 };

            for (long row = 0; row < height(); ++row) {
                for (long col = 0; col < width(); ++col) {
                    cr = 1.5 * (2.0 * col / width() - 1.0) - 0.5;
                    ci = (2.0 * row / height() - 1.0);

                    for (unsigned i = 0; i < MAX_ITERATIONS; ++i) {
                        prevr = nextr;
                        previ = nexti;

                        nextr = prevr * prevr - previ * previ + cr;
                        nexti = 2 * prevr * previ + ci;

                        if (((nextr * nextr) + (nexti * nexti)) > 4) {
                            const double z = ::sqrt(nextr * nextr + nexti * nexti);

                            // https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring
                            const unsigned int index =
                                static_cast<unsigned int>(1000.0 * log2(1.75 + i - log2(log2(z))) / log2(MAX_ITERATIONS));

                            pixels[col + row * height()] = colourmaps::JET.at(index);

                            break;
                        }
                    }
                }
            }
        }

        // look up https://en.wikipedia.org/wiki/Tricorn_(mathematics)
        void __cdecl tricorn() noexcept {
            // NOLINTNEXTLINE(readability-isolate-declaration)
            double            scaled_x_coordinate {} /* (-2.5, 1) */, scaled_y_coordinate {} /* (-1, 1) */; // of the pixel
            ::complex<double> scaled_coordinates {};

            constexpr auto     MAX_ITERATIONS { CMAPSIZE };
            volatile double    realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)
            unsigned long long iterations {};

            // for each pixel in the image
            for (long row = 0; row < height(); ++row) {
                for (long col = 0; col < width(); ++col) {
                    // dividing col by width gives a value (0, 1), multiplying that by 3.500 upscales to to (0, 3.5), then subtracting 2.5 gives us (-2.5, 1)
                    scaled_x_coordinate       = col / static_cast<double>(width()) * 3.50000 - 2.50000;
                    // dividing row by height will give a value (0, 1), by multiplying by 2 we could stretch it to (0, 2), then by subtracting 1, we could shift the range to (-1, 1)
                    scaled_y_coordinate       = row / static_cast<double>(height()) * 2.00000 - 1.00000;

                    scaled_coordinates.real() = scaled_x_coordinate;
                    scaled_coordinates.imag() = scaled_y_coordinate;

                    realsq                    = scaled_coordinates.real() * scaled_coordinates.real();
                    imagsq                    = scaled_coordinates.imag() * scaled_coordinates.imag();
                    iterations                = 0;

                    while (realsq + imagsq < 4.0000 && ++iterations < MAX_ITERATIONS) {
                        realtemp                  = realsq - imagsq + scaled_x_coordinate;
                        // IT IS ABSOULUTELY CRITICAL THAT WHEN THE IMAGINARY PART IS UPDATED, THE USED REAL PART SHOULD BE IN THE ORIGINAL (PREVIOUS) STATE
                        scaled_coordinates.imag() = -2.000 * scaled_coordinates.real() * scaled_coordinates.imag() + scaled_y_coordinate;
                        scaled_coordinates.real() = realtemp; // THUS UPDATING THE REAL PART AFTER THE UPDATE OF IMAGINARY PART
                    }

                    pixels[row * height() + col] = iterations == MAX_ITERATIONS ? BLACK : colourmaps::PRISM.at(iterations);
                }
            }
        }

        // look up https://en.wikipedia.org/wiki/Julia_set
        void __cdecl julia(
            _In_ const long&   width,
            _In_ const long&   height,
            _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
        ) noexcept {
            canvas            julia { width, height };
            ::complex<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

            const double   escaperadsq { escape_radius * escape_radius };
            constexpr auto MAX_ITERATIONS { CMAPSIZE };

            unsigned long iterations {};
            double        realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)

            // for each pixel in the image
            for (long row = 0; row < julia.height(); ++row) {
                for (long col = 0; col < julia.width(); ++col) {
                    // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                    // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                    // same goes for the col too
                    scaled_coordinates = { (col / static_cast<double>(julia.width()) * 2.000 - 1.0000) * escape_radius,
                                           (row / static_cast<double>(julia.height()) * 2.000 - 1.0000) * escape_radius };

                    iterations         = 0;
                    realsq             = scaled_coordinates.real() * scaled_coordinates.real();
                    imagsq             = scaled_coordinates.imag() * scaled_coordinates.imag();

                    while (realsq + imagsq < escaperadsq && ++iterations < MAX_ITERATIONS) {
                        //
                        realtemp           = realsq - imagsq;
                        scaled_coordinates = {};
                    }
                }
            }
        }

        // lookup https://en.wikipedia.org/wiki/Julia_set
        void __cdecl multijulia(
            _In_ const long&   width,
            _In_ const long&   height,
            _In_ const double& escape_radius // choose escape_radius > 0 such that escape_radius**2 - escape_radius >= sqrt(cx**2 + cy**2)
        ) noexcept {
            canvas            julia { width, height };
            ::complex<double> scaled_coordinates {}; // scaled between (-escape_radius, escape_radius)

            const auto     escaperadsq { escape_radius * escape_radius };
            constexpr auto MAX_ITERATIONS { CMAPSIZE };

            unsigned long iterations {};
            double        realtemp {}, realsq {}, imagsq {}; // NOLINT(readability-isolate-declaration)

            // for each pixel in the image
            for (long row = 0; row < julia.height(); ++row) {
                for (long col = 0; col < julia.width(); ++col) {
                    // dividing col by width will scale the value (0, 1), multiplication by 2 shifts the scale to (0, 2)
                    // subtracting 1 shifts to (-1, 1) and the ultimate multiplication by escape_radius will shift it to (-escape_radius, escape_radius)
                    // same goes for the col too
                    scaled_coordinates = { (col / static_cast<double>(julia.width()) * 2.000 - 1.0000) * escape_radius,
                                           (row / static_cast<double>(julia.height()) * 2.000 - 1.0000) * escape_radius };

                    iterations         = 0;
                    realsq             = scaled_coordinates.real() * scaled_coordinates.real();
                    imagsq             = scaled_coordinates.imag() * scaled_coordinates.imag();

                    while (realsq + imagsq < escaperadsq && ++iterations < MAX_ITERATIONS) {
                        //
                        realtemp           = realsq - imagsq;
                        scaled_coordinates = {};
                    }
                }
            }
        }
};
