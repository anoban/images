#pragma once
#include <bitmap>

#include <immintrin.h>

class canvas final : public bitmap { // a drawing canvas that uses bitmaps as their internal resource

    public:
        canvas(_In_ const long width, _In_ const long height) noexcept : bitmap { width, height } { }

        explicit canvas(_In_ const bitmap& image) noexcept : bitmap { image } { }

        explicit canvas(_In_ bitmap&& image) noexcept : bitmap { std::move(image) } { }

        ~canvas() noexcept = default;

        void fill(_In_ const RGBQUAD& pixel) noexcept { std::fill(begin(), end(), pixel); }

        // transform the image to black and white using the selected mechanism
        template<rgb::BW_TRANSFORMATION method> void to_blacknwhite() noexcept {
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE          : std::for_each(begin(), end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE : std::for_each(begin(), end(), rgb::transformers::weighted_average); break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY       : std::for_each(begin(), end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY           : std::for_each(begin(), end(), rgb::transformers::binary); break;
            }
        }

        template<rgb::BW_TRANSFORMATION method> [[nodiscard]] canvas to_blacknwhite() const noexcept {
            auto copy { *this };
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE : std::for_each(copy.begin(), copy.end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE :
                    std::for_each(copy.begin(), copy.end(), rgb::transformers::weighted_average);
                    break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY : std::for_each(copy.begin(), copy.end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY     : std::for_each(copy.begin(), copy.end(), rgb::transformers::binary); break;
            }
            return copy;
        }

        // remove the selected colours from the pixels of the image
        template<rgb::RGB_TAG colour_combination> void remove_colour() noexcept {
            std::for_each(begin(), end(), rgb::removers::zero<colour_combination> {});
        }

        template<rgb::RGB_TAG colour_combination> [[nodiscard]] canvas remove_colour() const noexcept {
            auto copy { *this };
            std::for_each(copy.begin(), copy.end(), rgb::removers::zero<colour_combination> {});
            return copy;
        }

        void hflip() noexcept { }

        [[nodiscard]] canvas hflip() const noexcept { }

        void vflip() noexcept { // reverse the order of scanlines in the image

            __m512i    top {}, bottom {};
            const auto residues { info_header.biWidth % sizeof(__m512i) };

            for (long row = 0; row < info_header.biHeight; ++row) {
                for (unsigned i = 0; i < info_header.biWidth - residues; i += sizeof(__m512i)) { // keep swapping the scanlines
                    //
                    bottom = _mm512_loadu_epi8(pixels + i);
                    top    = _mm512_loadu_epi8(pixels + i);
                }
            }
        }

        [[nodiscard]] canvas vflip() const noexcept { }

        [[nodiscard]] canvas copy() const noexcept { return *this; }

        [[nodiscard]] bitmap unwrap() const noexcept { return *this; }
};
