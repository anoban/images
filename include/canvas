#pragma once
#include <bitmap>

class canvas final { // a drawing canvas that uses bitmaps as their internal resource
    private:
        bitmap pane;

    public:
        canvas(_In_ const unsigned long long width, _In_ const unsigned long long height) noexcept : pane(width, height) { }

        explicit canvas(_In_ const bitmap& image) noexcept : pane { image } { }

        explicit canvas(_In_ bitmap&& image) noexcept : pane { std::move(image) } { }

        ~canvas() noexcept = default;

        decltype(auto) begin() noexcept { return pane.begin(); } // NOLINT(readability-make-member-function-const)

        decltype(auto) begin() const noexcept { return pane.begin(); }

        decltype(auto) cbegin() const noexcept { return pane.cbegin(); }

        decltype(auto) end() noexcept { return pane.end(); } // NOLINT(readability-make-member-function-const)

        decltype(auto) end() const noexcept { return pane.end(); }

        decltype(auto) cend() const noexcept { return pane.cend(); }

        decltype(auto) operator[](_In_ const bitmap::size_type offset) noexcept { // NOLINT(readability-make-member-function-const)
            return pane[offset];                                                  // NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)
        }

        decltype(auto) operator[](_In_ const bitmap::size_type offset) const noexcept {
            return pane[offset]; // NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)
        }

        void fill(_In_ const RGBQUAD& pixel) noexcept { std::fill(pane.begin(), pane.end(), pixel); }

        template<rgb::BW_TRANSFORMATION method> void to_blacknwhite() noexcept {
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE : std::for_each(pane.begin(), pane.end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE :
                    std::for_each(pane.begin(), pane.end(), rgb::transformers::weighted_average);
                    break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY : std::for_each(pane.begin(), pane.end(), rgb::transformers::luminosity); break;
                case rgb::BW_TRANSFORMATION::BINARY     : std::for_each(pane.begin(), pane.end(), rgb::transformers::binary); break;
            }
        }

        template<rgb::BW_TRANSFORMATION method> [[nodiscard]] canvas to_blacknwhite() const noexcept {
            auto copy { *this };
            switch (method) {
                case rgb::BW_TRANSFORMATION::AVERAGE : std::for_each(copy.pane.begin(), copy.pane.end(), rgb::transformers::average); break;
                case rgb::BW_TRANSFORMATION::WEIGHTED_AVERAGE :
                    std::for_each(copy.pane.begin(), copy.pane.end(), rgb::transformers::weighted_average);
                    break;
                case rgb::BW_TRANSFORMATION::LUMINOSITY :
                    std::for_each(copy.pane.begin(), copy.pane.end(), rgb::transformers::luminosity);
                    break;
                case rgb::BW_TRANSFORMATION::BINARY : std::for_each(copy.pane.begin(), copy.pane.end(), rgb::transformers::binary); break;
            }
            return copy;
        }

        template<rgb::RGB_TAG colour_combination> void remove_colour() noexcept {
            std::for_each(pane.begin(), pane.end(), rgb::removers::zero<colour_combination> {});
        }

        template<rgb::RGB_TAG colour_combination> [[nodiscard]] canvas remove_colour() const noexcept {
            auto copy { *this };
            std::for_each(copy.pane.begin(), copy.pane.end(), rgb::removers::zero<colour_combination> {});
            return copy;
        }

        decltype(auto) shape() const noexcept { return pane.dim(); }

        [[nodiscard]] canvas copy() const noexcept { return *this; }

        [[nodiscard]] bitmap unwrap() const noexcept { return pane; }

        decltype(auto) to_file(const wchar_t* const filepath) const noexcept { return pane.to_file(filepath); }
};
