#pragma once
#include <bitmap>
#include <helpers>
#include <imageio>

// most .ico files will have only one bitmap in them, so 4 is generous enough
static constexpr unsigned long long MAX_ALLOWED_ICONDIRENTRIES_PER_FILE { 4 };

// an ICO file can be imagined as a meta-info struct, called ICONDIR, for ICON DIRectory followed by a bitmap or an array of bitmaps
// (an .ico file can contain one or more images, hence the name icon directory), these bitmap images are stored contiguously, following the ICONDIR structure.
// each bitmap is defined by an ICONDIRENTRY struct in the ICONDIR struct
// the bitmap data can be in the format of a Windows BMP without the BITMAPFILEHEADER struct or a PNG image in its entirety i.e uncompressed.
// https://handwiki.org/wiki/ICO_(file_format)

// multibyte integers in .ico files are stored LSB first (using little endian byte order), just like .bmp files

// in summary, the binary representation of an .ico file looks like
// ICONDIR = { ICONDIRENTRY, pixels, <ICONDIRENTRY, pixels> ... }

enum class FILE_TYPE : unsigned short { ICON = 1, CURSOR }; // NOLINT(performance-enum-size) deliberate decision

enum class IMAGE_TYPE : int { BITMAP, PNG }; // NOLINT(performance-enum-size) deliberate decision, needs to be a signed integer

// look up Raymond Chen's article https://devblogs.microsoft.com/oldnewthing/20120720-00/?p=7083 for reference.

// typedef struct GRPICONDIRENTRY { // wingdi
//     BYTE  bWidth;
//     BYTE  bHeight;
//     BYTE  bColorCount;
//     BYTE  bReserved;
//     WORD  wPlanes;
//     WORD  wBitCount;
//     DWORD dwBytesInRes;
//     DWORD dwImageOffset;
// }

struct ICONDIRENTRY final {
        unsigned char  width;       // width of the associated bitmap in pixels (must be in the range of 0 to 256)
        unsigned char  height;      // height of the associated bitmap in pixels (must be in the range of 0 to 256)
        unsigned char  color_count; // number of colours in the colur palette, must be 0 if the bitmap doesn't use a colour palette.
        unsigned char  __;          // reserved byte, must always be 0.
        unsigned short planes;      // specifies the colour planes (should be 0 or 1) - for ICON
        // planes specifies the horizontal coordinate of the hotspot as offset from the left, in pixels - for CURSOR
        unsigned short bit_count; // specifies pixel depth - for ICON
        // bit_count specifies the vertical coordinate of the hotspot as offset from the top, in pixels - for CURSOR
        // Windows cursors have a hotspot location, that decides one exact point that is affected by mouse events https://learn.microsoft.com/en-us/windows/win32/menurc/about-cursors
        unsigned long  size;   // size of the associated bitmap in bytes
        unsigned long  offset; // offset of the associated bitmap data, from the beginning of the .ico or .cur file
};

static_assert(sizeof(ICONDIRENTRY) == 16, "");
static_assert(std::is_standard_layout<ICONDIRENTRY>::value, "");

//  typedef struct GRPICONDIR { // wingdi
//      WORD idReserved;
//      WORD idType;
//      WORD idCount;
//      GRPICONDIRENTRY idEntries[];
//  } GRPICONDIR;

struct ICONDIR final {
        unsigned short reserved;  // reserved field, must always be 0
        FILE_TYPE      type;      // specifies the type of the resources contained, values other than 1 and 2 are invalid
                                  // a given ICONDIR can store one or more of either icon or cursor type images
                                  // heterogeneous types aren't allowed inside an ICONDIR
        unsigned short count;     // number of resources (images) stored in the given .ico file
        ICONDIRENTRY*  resources; // marks the beginning of the first ICONDIRENTRY struct in the ICONDIR
};

static_assert(sizeof(ICONDIR) == 16, "");
static_assert(std::is_standard_layout<ICONDIR>::value, "");

class icon_directory final { // represents an .ico or .cur file object

        // clang-format off
#ifdef __TEST__
    public:
#endif
        // clang-format on

        unsigned char* buffer;      // the raw byte buffer
        unsigned long  file_size;   // file size
        unsigned long  buffer_size; // length of the buffer, may include trailing unused bytes if construction involved a buffer reuse
        unsigned short reserved;
        FILE_TYPE      type;
        unsigned short entry_count;
        std::array<unsigned, MAX_ALLOWED_ICONDIRENTRIES_PER_FILE>     entry_offsets; // offsets of each entry in the file buffer
        std::array<ICONDIRENTRY, MAX_ALLOWED_ICONDIRENTRIES_PER_FILE> entries;       // entries stored in the file

        // NOLINTBEGIN(readability-redundant-inline-specifier)

        inline bool __parse_icon_directory( // NOLINT(readability-convert-member-functions-to-static)
            _In_reads_bytes_(size) const unsigned char* const imstream,
            _In_ const unsigned long                          size
        ) noexcept {
            UNREFERENCED_PARAMETER(size);

            if (!imstream) {
                ::fputws(L"Error in " __FUNCTIONW__ ", the received buffer is empty!\n", stderr);
                return false;
            }

            reserved = *reinterpret_cast<const unsigned short*>(imstream);
            if (reserved) { // must be 0
                ::fputws(L"Error in " __FUNCTIONW__ ", a non zero value encountered as idReserved!\n", stderr);
                return false;
            }

            type = static_cast<FILE_TYPE>(
                *reinterpret_cast<const unsigned short*>(imstream + 2) // NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)
            );
            if (type != FILE_TYPE::ICON && type != FILE_TYPE::CURSOR) { // cannot be anything else
                ::fputws(L"Error in " __FUNCTIONW__ ", file is found not to be of type ICON or CURSOR!\n", stderr);
                return false;
            }

            // we're 4 bytes past the beginning of the buffer now
            entry_count = *reinterpret_cast<const unsigned short*>(imstream + 4); // NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)
            // handle if the file contains more resources than MAX_ALLOWED_ICONDIRENTRIES_PER_FILE
            if (entry_count > MAX_ALLOWED_ICONDIRENTRIES_PER_FILE) {
                ::fputws(L"Error in " __FUNCTIONW__ ", file contains more ICONDIRENTRYs than this class can accomodate!\n", stderr);
                return false;
            }

            return true;
        }

        // it is the caller's responsibility to correctly augment the buffer such that it begins with the binary data of a ICONDIRENTRY
        constexpr inline ICONDIRENTRY __parse_icondir_entry( // NOLINT(readability-convert-member-functions-to-static)
            _In_count_(size) const unsigned char* const imstream,
            _In_ const unsigned long                    size
        ) noexcept {
            UNREFERENCED_PARAMETER(size);

            if (!imstream) return {};
            ICONDIRENTRY temp {};

            // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic)
            temp.width       = *imstream;
            temp.height      = *(imstream + 1);
            temp.color_count = *(imstream + 2);
            temp.__          = *(imstream + 3);

            assert(!temp.__); // must always be 0

            temp.planes    = *reinterpret_cast<const unsigned short*>(imstream + 4);
            temp.bit_count = *reinterpret_cast<const unsigned short*>(imstream + 6);
            temp.size      = *reinterpret_cast<const unsigned long*>(imstream + 8);
            temp.offset    = *reinterpret_cast<const unsigned long*>(imstream + 12);
            // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)

            return temp;
        }

    public:
        // using value_type                 = RGBQUAD; // pixel type
        // using pointer                    = value_type*;
        // using const_pointer              = const value_type*;
        // using reference                  = value_type&;
        // using const_reference            = const value_type&;
        // using iterator                   = value_type*;
        // using const_iterator             = const value_type*;
        using size_type                  = unsigned long long;
        using difference_type            = long long;

        inline icon_directory() noexcept = default;

        inline explicit icon_directory(_In_ const wchar_t* const filename) noexcept :
            buffer { internal::open(filename, file_size) }, buffer_size { file_size } {
            if (!buffer) {
                ::fputws(L"Error inside " __FUNCTIONW__ ", parsing failed, object is default initialized as a fallback\n", stderr);
                return;
            }

            if (!__parse_icon_directory(buffer, file_size)) { // will initialize reserved, type and entry count
                ::fputws(L"Error inside " __FUNCTIONW__ ", parsing failed, object is default initialized as a fallback\n", stderr);
                ::memset(this, 0U, sizeof(icon_directory)); // NOLINT(bugprone-undefined-memory-manipulation)
                return;
            }

            for (unsigned i = 0; i < entry_count; ++i) { // try and parse all the ICONDIRENTRYs in the file
                //
            }
        }

        inline icon_directory(_In_ const icon_directory& other) noexcept { }

        inline icon_directory& operator=(_In_ const icon_directory& other) noexcept { }

        inline icon_directory(_In_ icon_directory&& other) noexcept { }

        inline icon_directory& operator=(_In_ icon_directory&& other) noexcept { }

        inline ~icon_directory() noexcept {
            delete[] buffer;
            ::memset(this, 0U, sizeof(icon_directory)); // NOLINT(bugprone-undefined-memory-manipulation)
        }

        inline size_type image_count() const noexcept { return entry_count; }

        inline bool to_file(_In_ const wchar_t* const filename) const noexcept {
            return internal::serialize(filename, buffer, buffer_size);
        }

        inline bitmap image_to_bitmap(_In_opt_ const unsigned position = 0) const noexcept { }
        // NOLINTEND(readability-redundant-inline-specifier)
};

static_assert(std::is_standard_layout<icon_directory>::value, "");
static_assert(sizeof(icon_directory) == 104, "");
